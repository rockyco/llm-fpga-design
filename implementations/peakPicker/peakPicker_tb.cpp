/* AUTO-EDITED BY DEBUG ASSISTANT */
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <cmath>    // For fabs
#include <limits>   // For numeric_limits
#include <iomanip>  // For std::setw, std::fixed, std::setprecision

#include "peakPicker.hpp" // Include the header for the DUT

//--------------------------------------------------------------------------
// Testbench Constants
//--------------------------------------------------------------------------
const std::string XCORR_INPUT_FILE = "pssCorrMagSq_3_in.txt";
const std::string THRESHOLD_INPUT_FILE = "threshold_in.txt";
const std::string LOCATIONS_REF_FILE = "locations_3_ref.txt";
const std::string LOCATIONS_OUT_FILE = "peakLocs_out.txt"; // Matches MATLAB tb output name

//--------------------------------------------------------------------------
// Helper Functions for File I/O
//--------------------------------------------------------------------------

// Reads floating-point data from a file into a vector
bool readData(const std::string& filename, std::vector<double>& data) {
    std::ifstream ifs(filename);
    if (!ifs.is_open()) {
        std::cerr << "ERROR: Could not open file: " << filename << std::endl;
        return false;
    }
    double val;
    while (ifs >> val) {
        data.push_back(val);
    }
    if (ifs.bad()) {
        std::cerr << "ERROR: Error reading file: " << filename << std::endl;
        return false;
    }
    ifs.close();
    std::cout << "INFO: Read " << data.size() << " values from " << filename << std::endl;
    return !data.empty(); // Consider empty file an error? Yes for this TB.
}

// Reads integer data from a file into a vector
bool readIntData(const std::string& filename, std::vector<int>& data) {
    std::ifstream ifs(filename);
    if (!ifs.is_open()) {
        std::cerr << "ERROR: Could not open file: " << filename << std::endl;
        return false;
    }
    int val;
    // Handle potential empty reference file (no peaks found)
    while (ifs >> val) {
        data.push_back(val);
    }
     if (ifs.bad() && !ifs.eof()) { // Check for read errors, ignore EOF
        std::cerr << "ERROR: Error reading file: " << filename << std::endl;
        return false;
    }
    ifs.close();
    std::cout << "INFO: Read " << data.size() << " integer values from " << filename << std::endl;
    // Allow empty reference file (0 peaks)
    return true;
}

// Writes integer data from a vector to a file
bool writeIntData(const std::string& filename, const std::vector<LocationType>& data) {
    std::ofstream ofs(filename);
    if (!ofs.is_open()) {
        std::cerr << "ERROR: Could not open file for writing: " << filename << std::endl;
        return false;
    }
    // Write one value per line, matching MATLAB writematrix default for vectors
    for (const auto& val : data) {
        ofs << val << std::endl;
    }
    if (ofs.bad()) {
        std::cerr << "ERROR: Error writing to file: " << filename << std::endl;
        return false;
    }
    ofs.close();
    std::cout << "INFO: Wrote " << data.size() << " integer values to " << filename << std::endl;
    return true;
}


//--------------------------------------------------------------------------
// Main Testbench Function
//--------------------------------------------------------------------------
int main() {
    std::cout << "INFO: Starting Peak Picker HLS C++ Testbench..." << std::endl;

    // --- Input Data Reading ---
    std::vector<double> xcorrInputDouble;
    std::vector<double> thresholdInputDouble;
    std::vector<int>    locationsRef;

    if (!readData(XCORR_INPUT_FILE, xcorrInputDouble)) return 1;
    if (!readData(THRESHOLD_INPUT_FILE, thresholdInputDouble)) return 1;
    if (!readIntData(LOCATIONS_REF_FILE, locationsRef)) return 1;

    // --- Input Data Validation ---
    if (xcorrInputDouble.size() != thresholdInputDouble.size()) {
        std::cerr << "ERROR: Input xcorr (" << xcorrInputDouble.size()
                  << ") and threshold (" << thresholdInputDouble.size()
                  << ") vectors must have the same size." << std::endl;
        return 1;
    }
    if (xcorrInputDouble.empty()) {
         std::cerr << "ERROR: Input data files are empty or could not be read." << std::endl;
         return 1;
    }

    int numSamples = xcorrInputDouble.size();
    std::cout << "INFO: Number of samples to process: " << numSamples << std::endl;

    // --- Convert Reference Locations (Potential 1-based to 0-based) ---
    // Assuming the reference file was generated by MATLAB (1-based indexing)
    // and the HLS DUT produces 0-based indices.
    // If the reference file *already* contains 0-based indices, comment out this block.
    std::cout << "INFO: Converting reference locations from assumed 1-based (e.g., MATLAB) to 0-based (C++) for comparison." << std::endl;
    for (int& loc : locationsRef) {
        loc = loc - 1; // Convert 1-based index to 0-based index
        if (loc < 0) {
             std::cerr << "ERROR: Found invalid negative location (" << loc + 1 << " in ref file) after 1-based to 0-based conversion." << std::endl;
             return 1; // Error out if conversion results in invalid index
        }
    }
    std::cout << "INFO: Reference locations converted to 0-based." << std::endl;


    // --- HLS Stream Preparation ---
    XcorrStream xcorrStream("xcorrStream");
    ThresholdStream thresholdStream("thresholdStream");
    LocationStream locationStream("locationStream");
    std::vector<LocationType> locationsHLS; // To store DUT output

    // --- Populate Input Streams ---
    std::cout << "INFO: Populating input streams..." << std::endl;
    for (int i = 0; i < numSamples; ++i) {
        // Convert double input to fixed-point DataType for the DUT
        DataType xcorrFixed = xcorrInputDouble[i];
        DataType thresholdFixed = thresholdInputDouble[i];
        xcorrStream.write(xcorrFixed);
        thresholdStream.write(thresholdFixed);
    }
    std::cout << "INFO: Input streams populated." << std::endl;

    // --- Execute the DUT (Device Under Test) ---
    std::cout << "INFO: Executing peakPicker DUT..." << std::endl;
    peakPicker(xcorrStream, thresholdStream, numSamples, locationStream);
    std::cout << "INFO: DUT execution finished." << std::endl;

    // --- Collect Output Stream ---
    std::cout << "INFO: Collecting results from output stream..." << std::endl;
    while (!locationStream.empty()) {
        LocationType loc;
        locationStream.read(loc);
        locationsHLS.push_back(loc);
    }
    std::cout << "INFO: Collected " << locationsHLS.size() << " peak locations from HLS DUT." << std::endl;

    // --- Write HLS Output to File ---
    if (!writeIntData(LOCATIONS_OUT_FILE, locationsHLS)) {
        std::cerr << "ERROR: Failed to write HLS output locations to file." << std::endl;
        // Continue to comparison if possible
    }

    // --- Verification ---
    std::cout << "INFO: Comparing HLS results (0-based) with converted reference (0-based)..." << std::endl;
    bool match = true;
    int errors = 0;

    // Compare number of peaks found
    if (locationsHLS.size() != locationsRef.size()) {
        std::cerr << "ERROR: Mismatch in number of peaks found!" << std::endl;
        std::cerr << "  Reference (0-based): " << locationsRef.size() << std::endl;
        std::cerr << "  HLS DUT (0-based):   " << locationsHLS.size() << std::endl;
        match = false;
        // Don't reset errors here, size mismatch is the primary error in this case
        errors = 1; // Indicate at least one error
    } else {
        std::cout << "INFO: Number of peaks matches reference (" << locationsRef.size() << ")." << std::endl;
    }

    // Compare individual peak locations if sizes match (or compare up to the minimum size if they don't, to show mismatches)
    int compareCount = std::min((int)locationsHLS.size(), (int)locationsRef.size()); // Cast to int for comparison
    if (compareCount > 0 && errors == 0) { // Only compare elements if sizes matched initially
        std::cout << "INFO: Comparing individual peak locations..." << std::endl;
    }

    for (int i = 0; i < compareCount; ++i) {
        if (locationsHLS[i] != locationsRef[i]) {
            if (errors == 0) { // Print header only on first value error
                 std::cerr << "ERROR: Mismatch in peak locations:" << std::endl;
                 std::cerr << std::setw(10) << "Index" << std::setw(20) << "HLS Output (0-based)" << std::setw(20) << "Reference (0-based)" << std::endl;
            }
            std::cerr << std::setw(10) << i
                      << std::setw(20) << locationsHLS[i]
                      << std::setw(20) << locationsRef[i] << std::endl;
            match = false;
            errors++;
        }
    }

    // --- Report Final Result ---
    if (match) {
        std::cout << "----------------------------------------" << std::endl;
        std::cout << "INFO: Test PASSED!" << std::endl;
        std::cout << "----------------------------------------" << std::endl;
        return 0; // Success
    } else {
        std::cerr << "----------------------------------------" << std::endl;
        // Report includes size mismatch OR number of value mismatches
        if (locationsHLS.size() != locationsRef.size()) {
             std::cerr << "ERROR: Test FAILED! Mismatch in number of peaks found." << std::endl;
        } else {
             std::cerr << "ERROR: Test FAILED! Found " << errors << " mismatches in peak location values." << std::endl;
        }
        std::cerr << "----------------------------------------" << std::endl;
        return 1; // Failure
    }
}